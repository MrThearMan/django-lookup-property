{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django Lookup Property \ud83d\udd17 1 pip install django-lookup-property Documentation : https://mrthearman.github.io/django-lookup-property/ Source Code : https://github.com/MrThearMan/django-lookup-property/ Contributing : https://github.com/MrThearMan/django-lookup-property/blob/main/CONTRIBUTING.md Django model properties that are also lookup expressions. 1 2 3 4 5 6 7 8 9 10 11 12 from lookup_property import lookup_property from django.db import models from django.db.models import Value from django.db.models.functions import Concat class Student ( models . Model ): first_name = models . CharField ( max_length = 256 ) last_name = models . CharField ( max_length = 256 ) @lookup_property def full_name (): return Concat ( \"first_name\" , Value ( \" \" ), \"last_name\" ) 1 2 3 4 5 6 7 8 >>> from myapp.models import Student >>> from lookup_property import L >>> >>> Student . objects . create ( first_name = \"John\" , last_name = \"Doe\" ) >>> student = Student . objects . filter ( L ( full_name = \"John Doe\" )) . first () >>> >>> student . full_name 'John Doe'","title":"Home"},{"location":"#django-lookup-property","text":"1 pip install django-lookup-property Documentation : https://mrthearman.github.io/django-lookup-property/ Source Code : https://github.com/MrThearMan/django-lookup-property/ Contributing : https://github.com/MrThearMan/django-lookup-property/blob/main/CONTRIBUTING.md Django model properties that are also lookup expressions. 1 2 3 4 5 6 7 8 9 10 11 12 from lookup_property import lookup_property from django.db import models from django.db.models import Value from django.db.models.functions import Concat class Student ( models . Model ): first_name = models . CharField ( max_length = 256 ) last_name = models . CharField ( max_length = 256 ) @lookup_property def full_name (): return Concat ( \"first_name\" , Value ( \" \" ), \"last_name\" ) 1 2 3 4 5 6 7 8 >>> from myapp.models import Student >>> from lookup_property import L >>> >>> Student . objects . create ( first_name = \"John\" , last_name = \"Doe\" ) >>> student = Student . objects . filter ( L ( full_name = \"John Doe\" )) . first () >>> >>> student . full_name 'John Doe'","title":"Django Lookup Property"},{"location":"converters/","text":"Converters \ud83d\udd17 The examples discussed here are already implemented and are given just as a simple illustration of usage. Expressions \ud83d\udd17 The @lookup_property decorator uses a single-dispatch function lookup_property.converters.expressions.expression_to_ast to register a number of converters for transforming Django ORM expressions to equivalent python statement AST . Let's take a look at our example from before: 1 2 3 4 5 6 7 8 9 10 11 12 from lookup_property import lookup_property from django.db import models from django.db.models import Value from django.db.models.functions import Concat class Student ( models . Model ): first_name = models . CharField ( max_length = 256 ) last_name = models . CharField ( max_length = 256 ) @lookup_property def full_name ( self ): return Concat ( \"first_name\" , Value ( \" \" ), \"last_name\" ) Here are the converters required to transform this to a python statement AST: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import ast from django.db import models from django.db.models import functions from lookup_property import expression_to_ast , State from lookup_property.converters.utils import ast_property @expression_to_ast . register def _ ( expression : str , state : State ) -> ast . Constant : # Called by converters for Value and ConcatPair to convert # the strings they contain to ast constants. return ast . Constant ( value = expression ) @expression_to_ast . register def _ ( expression : models . Value , state : State ) -> ast . AST : # Convert the `value` inside the Value-class to ast constant. # Notice `expression_to_ast` is called recursively. return expression_to_ast ( expression . value , state ) @expression_to_ast . register def _ ( expression : models . F , state : State ) -> ast . Attribute : # Convert F-objects to self-attributes. # This is such a common operation that the library provides a utility for it. return ast_property ( expression . name ) @expression_to_ast . register def _ ( expression : functions . Concat , state : State ) -> ast . AST : # Concat is composed of nested ConcatPair-expressions: # Concat((ConcatPair(\"foo\", ConcatPair(\"bar\", \"baz\")))) # Convert the concat pairs recursively. source_expressions = expression . get_source_expressions () return expression_to_ast ( source_expressions [ 0 ], state ) @expression_to_ast . register def _ ( expression : functions . ConcatPair , state : State ) -> ast . BinOp : # First convert the left and right ConcatPair elements # to their AST nodes (string constants in this case) # and then compose them into a BinOp (left + right) source_expressions = expression . get_source_expressions () left = expression_to_ast ( source_expressions [ 0 ], state ) right = expression_to_ast ( source_expressions [ 1 ], state ) return ast . BinOp ( left = left , op = ast . Add (), right = right ) Lookups \ud83d\udd17 To convert lookups inside L and Q expressions, there is another single-dispatch function lookup_property.converters.lookups.lookup_to_ast . For example, to convert the following lookup-property: 1 2 3 4 5 6 7 8 9 from lookup_property import lookup_property from django.db import models class Student ( models . Model ): name = models . CharField ( max_length = 256 ) @lookup_property def start_with_letter_a ( self ): return models . Q ( name__startswith = \"A\" ) Here's the lookup converter required to transform this to a python statement AST: 1 2 3 4 5 6 7 8 9 10 11 12 13 import ast from django.db.models import lookups from lookup_property import lookup_to_ast , expression_to_ast , State from lookup_property.converters.utils import ast_method # This is a custom single-dispatch function, and registering works # a bit differently: `lookup` keyword must be specified for register. # Q(foo__bar__lookup=val) -> (attrs: [\"foo\", \"bar\"], value: val) @lookup_to_ast . register ( lookup = lookups . StartsWith . lookup_name ) def _ ( attrs : list [ str ], value : str , state : State ) -> ast . Call : # `ast_method` is another utility function, which outputs the AST # for a method like: self.foo.bar.method(*args, **kwargs) return ast_method ( \"startswith\" , attrs , expression_to_ast ( value , state )) Casts \ud83d\udd17 Yet another single-dispatch function exists for the Cast operation, and can be used to select a proper callable for conversion. 1 2 3 4 5 6 7 8 9 import ast from django.db import models from lookup_property import State , convert_django_field @convert_django_field . register def _ ( field : models . BooleanField , state : State ) -> ast . Name : # Should return the name of the function that can be used # to convert to the given model field type return ast . Name ( id = \"bool\" , ctx = ast . Load ())","title":"Converters"},{"location":"converters/#converters","text":"The examples discussed here are already implemented and are given just as a simple illustration of usage.","title":"Converters"},{"location":"converters/#expressions","text":"The @lookup_property decorator uses a single-dispatch function lookup_property.converters.expressions.expression_to_ast to register a number of converters for transforming Django ORM expressions to equivalent python statement AST . Let's take a look at our example from before: 1 2 3 4 5 6 7 8 9 10 11 12 from lookup_property import lookup_property from django.db import models from django.db.models import Value from django.db.models.functions import Concat class Student ( models . Model ): first_name = models . CharField ( max_length = 256 ) last_name = models . CharField ( max_length = 256 ) @lookup_property def full_name ( self ): return Concat ( \"first_name\" , Value ( \" \" ), \"last_name\" ) Here are the converters required to transform this to a python statement AST: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import ast from django.db import models from django.db.models import functions from lookup_property import expression_to_ast , State from lookup_property.converters.utils import ast_property @expression_to_ast . register def _ ( expression : str , state : State ) -> ast . Constant : # Called by converters for Value and ConcatPair to convert # the strings they contain to ast constants. return ast . Constant ( value = expression ) @expression_to_ast . register def _ ( expression : models . Value , state : State ) -> ast . AST : # Convert the `value` inside the Value-class to ast constant. # Notice `expression_to_ast` is called recursively. return expression_to_ast ( expression . value , state ) @expression_to_ast . register def _ ( expression : models . F , state : State ) -> ast . Attribute : # Convert F-objects to self-attributes. # This is such a common operation that the library provides a utility for it. return ast_property ( expression . name ) @expression_to_ast . register def _ ( expression : functions . Concat , state : State ) -> ast . AST : # Concat is composed of nested ConcatPair-expressions: # Concat((ConcatPair(\"foo\", ConcatPair(\"bar\", \"baz\")))) # Convert the concat pairs recursively. source_expressions = expression . get_source_expressions () return expression_to_ast ( source_expressions [ 0 ], state ) @expression_to_ast . register def _ ( expression : functions . ConcatPair , state : State ) -> ast . BinOp : # First convert the left and right ConcatPair elements # to their AST nodes (string constants in this case) # and then compose them into a BinOp (left + right) source_expressions = expression . get_source_expressions () left = expression_to_ast ( source_expressions [ 0 ], state ) right = expression_to_ast ( source_expressions [ 1 ], state ) return ast . BinOp ( left = left , op = ast . Add (), right = right )","title":"Expressions"},{"location":"converters/#lookups","text":"To convert lookups inside L and Q expressions, there is another single-dispatch function lookup_property.converters.lookups.lookup_to_ast . For example, to convert the following lookup-property: 1 2 3 4 5 6 7 8 9 from lookup_property import lookup_property from django.db import models class Student ( models . Model ): name = models . CharField ( max_length = 256 ) @lookup_property def start_with_letter_a ( self ): return models . Q ( name__startswith = \"A\" ) Here's the lookup converter required to transform this to a python statement AST: 1 2 3 4 5 6 7 8 9 10 11 12 13 import ast from django.db.models import lookups from lookup_property import lookup_to_ast , expression_to_ast , State from lookup_property.converters.utils import ast_method # This is a custom single-dispatch function, and registering works # a bit differently: `lookup` keyword must be specified for register. # Q(foo__bar__lookup=val) -> (attrs: [\"foo\", \"bar\"], value: val) @lookup_to_ast . register ( lookup = lookups . StartsWith . lookup_name ) def _ ( attrs : list [ str ], value : str , state : State ) -> ast . Call : # `ast_method` is another utility function, which outputs the AST # for a method like: self.foo.bar.method(*args, **kwargs) return ast_method ( \"startswith\" , attrs , expression_to_ast ( value , state ))","title":"Lookups"},{"location":"converters/#casts","text":"Yet another single-dispatch function exists for the Cast operation, and can be used to select a proper callable for conversion. 1 2 3 4 5 6 7 8 9 import ast from django.db import models from lookup_property import State , convert_django_field @convert_django_field . register def _ ( field : models . BooleanField , state : State ) -> ast . Name : # Should return the name of the function that can be used # to convert to the given model field type return ast . Name ( id = \"bool\" , ctx = ast . Load ())","title":"Casts"},{"location":"intro/","text":"Introduction \ud83d\udd17 Simple use case \ud83d\udd17 Let's say we have a model with two fields, first_name and last_name . We want to create a property full_name that concatenates the two fields, but we also want to use this property in a queryset to filter rows. Furthermore, we want this to work from related models as well. Normally, we would need to create the property and the ORM expression separately - the property on the model and the expression in the queryset, creating duplication and distance between the two pieces of code. To be able to use the filter from related models, we would also need to create some function to generate the expression with the necessary joins for each situation it is used in. For simple properties, you might just write the expression multiple times, but for more complex properties this will introduce a lot of complexity that you need to keep in sync. Lookup property allows us to define the property and ORM expression in one go, and then use the property in a queryset, even on related models. 1 2 3 4 5 6 7 8 9 10 11 12 from lookup_property import lookup_property from django.db import models from django.db.models import Value from django.db.models.functions import Concat class Student ( models . Model ): first_name = models . CharField ( max_length = 256 ) last_name = models . CharField ( max_length = 256 ) @lookup_property def full_name (): return Concat ( \"first_name\" , Value ( \" \" ), \"last_name\" ) Django 5.0 introduced GeneratedField , which can be used for this purpose. However, it's not as flexible as the lookup property, and doesn't support all the features of the Django ORM, mainly related lookups. We'll go over these in more detail later. Overview \ud83d\udd17 The method decorated by the lookup_property decorator is added the model as a special LookupPropertyField . This allows QuerySets to find it from the model. The method should be static, and return a Django ORM expression, which is used as the value of the field in QuerySets. Even though the method is static, you can still refer to other fields on the model using Django's F object. For the python property, the expression is converted to a regular python code using pre-defined converters. The converters create a python AST from the expression, which is then evaluated using eval() . The library already provides converters for most of the common expressions, but it's also possible to register new converters or replace existing ones (see. converters ). While use of eval() should generally be avoided due to security concerns, here the risks are minimal, since the evaluation only happens once during class creation, and from existing code rather than user input. Still, any extensions like new converters should keep this in mind, and not, for example, read any input from a database during the conversion process. You can inspect the generated python source from the class: 1 2 3 4 5 >>> Student . full_name . func_source \"\"\" def full_name(self): return self.first_name + (' ' + self.last_name) \"\"\" Notice that the generated expression does contain a self-reference, even though the original lookup property didn't. This is for F expressions to be able to reference the fields on the model. You should always inspect and test the generated source to make sure it's what you expect, especially if you're using complex expressions or custom converters. Override \ud83d\udd17 If you don't like the python auto-generation, or want to write a more optimal code yourself, you can override the generated expression with a custom one: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from lookup_property import lookup_property from django.db import models class Student ( models . Model ): first_name = models . CharField ( max_length = 256 ) last_name = models . CharField ( max_length = 256 ) @lookup_property ( skip_codegen = True ) def full_name (): return ... @full_name . override def _ ( self ): return f \" { self . first_name } { self . last_name } \" By doing this, you'll be trading reduced code duplication for correctness and performance, and you'll need start keeping the expression in sync with the property manually. The use of the skip_codegen argument is required when using overrides. Otherwise, the lookup expression would try to convert the expression the python code, only to be overridden. We need to explicitly tell this to the lookup property, because the conversion happens immediately at class creation time, and the override is only added to the class after it. Related models \ud83d\udd17 Lookup properties can also reference related models. While some expressions might work without any additional setup in some cases, it's recommended to specify the joins in for these lookup properties manually. 1 2 3 4 5 6 7 8 9 10 11 12 13 from lookup_property import lookup_property from django.db import models class Student ( models . Model ): ... @lookup_property ( joins = [ \"classes\" ]) def number_of_classes ( self ): return models . Count ( \"classes\" ) class Class ( models . Model ): students = models . ManyToManyField ( Student , related_name = \"classes\" ) ... Concrete properties \ud83d\udd17 Lookup properties are not included in select statements by default. This is because the properties can contain joins, which we might not want to do for every query. If you do want this behavior, you can use the concrete argument to always \"annotate\" the lookup property on the model when it is fetched from the database: 1 2 3 4 5 6 7 8 9 from lookup_property import lookup_property from django.db import models class Student ( models . Model ): ... @lookup_property ( concrete = True ) def full_name (): return ...","title":"Introduction"},{"location":"intro/#introduction","text":"","title":"Introduction"},{"location":"intro/#simple-use-case","text":"Let's say we have a model with two fields, first_name and last_name . We want to create a property full_name that concatenates the two fields, but we also want to use this property in a queryset to filter rows. Furthermore, we want this to work from related models as well. Normally, we would need to create the property and the ORM expression separately - the property on the model and the expression in the queryset, creating duplication and distance between the two pieces of code. To be able to use the filter from related models, we would also need to create some function to generate the expression with the necessary joins for each situation it is used in. For simple properties, you might just write the expression multiple times, but for more complex properties this will introduce a lot of complexity that you need to keep in sync. Lookup property allows us to define the property and ORM expression in one go, and then use the property in a queryset, even on related models. 1 2 3 4 5 6 7 8 9 10 11 12 from lookup_property import lookup_property from django.db import models from django.db.models import Value from django.db.models.functions import Concat class Student ( models . Model ): first_name = models . CharField ( max_length = 256 ) last_name = models . CharField ( max_length = 256 ) @lookup_property def full_name (): return Concat ( \"first_name\" , Value ( \" \" ), \"last_name\" ) Django 5.0 introduced GeneratedField , which can be used for this purpose. However, it's not as flexible as the lookup property, and doesn't support all the features of the Django ORM, mainly related lookups. We'll go over these in more detail later.","title":"Simple use case"},{"location":"intro/#overview","text":"The method decorated by the lookup_property decorator is added the model as a special LookupPropertyField . This allows QuerySets to find it from the model. The method should be static, and return a Django ORM expression, which is used as the value of the field in QuerySets. Even though the method is static, you can still refer to other fields on the model using Django's F object. For the python property, the expression is converted to a regular python code using pre-defined converters. The converters create a python AST from the expression, which is then evaluated using eval() . The library already provides converters for most of the common expressions, but it's also possible to register new converters or replace existing ones (see. converters ). While use of eval() should generally be avoided due to security concerns, here the risks are minimal, since the evaluation only happens once during class creation, and from existing code rather than user input. Still, any extensions like new converters should keep this in mind, and not, for example, read any input from a database during the conversion process. You can inspect the generated python source from the class: 1 2 3 4 5 >>> Student . full_name . func_source \"\"\" def full_name(self): return self.first_name + (' ' + self.last_name) \"\"\" Notice that the generated expression does contain a self-reference, even though the original lookup property didn't. This is for F expressions to be able to reference the fields on the model. You should always inspect and test the generated source to make sure it's what you expect, especially if you're using complex expressions or custom converters.","title":"Overview"},{"location":"intro/#override","text":"If you don't like the python auto-generation, or want to write a more optimal code yourself, you can override the generated expression with a custom one: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from lookup_property import lookup_property from django.db import models class Student ( models . Model ): first_name = models . CharField ( max_length = 256 ) last_name = models . CharField ( max_length = 256 ) @lookup_property ( skip_codegen = True ) def full_name (): return ... @full_name . override def _ ( self ): return f \" { self . first_name } { self . last_name } \" By doing this, you'll be trading reduced code duplication for correctness and performance, and you'll need start keeping the expression in sync with the property manually. The use of the skip_codegen argument is required when using overrides. Otherwise, the lookup expression would try to convert the expression the python code, only to be overridden. We need to explicitly tell this to the lookup property, because the conversion happens immediately at class creation time, and the override is only added to the class after it.","title":"Override"},{"location":"intro/#related-models","text":"Lookup properties can also reference related models. While some expressions might work without any additional setup in some cases, it's recommended to specify the joins in for these lookup properties manually. 1 2 3 4 5 6 7 8 9 10 11 12 13 from lookup_property import lookup_property from django.db import models class Student ( models . Model ): ... @lookup_property ( joins = [ \"classes\" ]) def number_of_classes ( self ): return models . Count ( \"classes\" ) class Class ( models . Model ): students = models . ManyToManyField ( Student , related_name = \"classes\" ) ...","title":"Related models"},{"location":"intro/#concrete-properties","text":"Lookup properties are not included in select statements by default. This is because the properties can contain joins, which we might not want to do for every query. If you do want this behavior, you can use the concrete argument to always \"annotate\" the lookup property on the model when it is fetched from the database: 1 2 3 4 5 6 7 8 9 from lookup_property import lookup_property from django.db import models class Student ( models . Model ): ... @lookup_property ( concrete = True ) def full_name (): return ...","title":"Concrete properties"},{"location":"usage/","text":"Usage \ud83d\udd17 Filtering \ud83d\udd17 You can use the lookup property in queries by referring to it inside a special L expression: 1 2 3 4 5 >>> from myapp.models import Student >>> from lookup_property import L >>> >>> Student . objects . create ( first_name = \"John\" , last_name = \"Doe\" ) >>> Student = Student . objects . filter ( L ( full_name = \"John Doe\" )) . first () The L expression will find the lookup property on the model, and replace it with the expression defined by it. This allows you to use the property in queries as if it was a normal field. You can also use the lookup property as the filter value: 1 >>> Person . objects . filter ( first_name = L ( \"full_name\" )) For more complex filters, L expressions can also be used inside Q expressions: 1 2 >>> from django.db.models import Q >>> Person . objects . filter ( Q ( first_name = L ( \"full_name\" )) | Q ( L ( full_name = \"John Doe\" ))) Annotating \ud83d\udd17 You can also annotate the lookup property to pre-calculate it in the QuerySet. 1 2 3 >>> Student = Student . objects . annotate ( full_name = L ( \"full_name\" )) . first () >>> Student . full_name 'John Doe' This bypasses the python code/override, which can be more efficient when fetching multiple rows at once (especially if the property contains complex expressions or joins). See the concrete argument on lookup_property decorator if you always want this behavior. Related lookups \ud83d\udd17 The L expression also allows you to use the lookup property in related lookups: 1 >>> Class . objects . filter ( L ( students__full_name = \"John Doe\" )) This will find the appropriate model where the lookup property is defined and add the necessary joins to the query automatically. Subqueries \ud83d\udd17 If the lookup property is used in a subquery in an OuterRef, note that the L expression should wrap the whole subquery, and not just the OuterRef, since the lookup property is located in the outer query model and not the subquery model. 1 2 3 4 5 >>> from django.db.models import OuterRef , Subquery >>> from myapp.models import Class , Person >>> >>> sq = Class . objecs . filter ( teacher_name = OuterRef ( \"full_name\" )) . values ( \"pk\" ) >>> Person . objects . filter ( id__in = L ( models . Subquery ( sq ))) Additional lookups \ud83d\udd17 Lookup property can be used with additional lookups, such as __in , __lt , __gt , etc. 1 >>> Student . objects . filter ( L ( full_name__in = [ \"John Doe\" , \"Jane Doe\" ]))","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#filtering","text":"You can use the lookup property in queries by referring to it inside a special L expression: 1 2 3 4 5 >>> from myapp.models import Student >>> from lookup_property import L >>> >>> Student . objects . create ( first_name = \"John\" , last_name = \"Doe\" ) >>> Student = Student . objects . filter ( L ( full_name = \"John Doe\" )) . first () The L expression will find the lookup property on the model, and replace it with the expression defined by it. This allows you to use the property in queries as if it was a normal field. You can also use the lookup property as the filter value: 1 >>> Person . objects . filter ( first_name = L ( \"full_name\" )) For more complex filters, L expressions can also be used inside Q expressions: 1 2 >>> from django.db.models import Q >>> Person . objects . filter ( Q ( first_name = L ( \"full_name\" )) | Q ( L ( full_name = \"John Doe\" )))","title":"Filtering"},{"location":"usage/#annotating","text":"You can also annotate the lookup property to pre-calculate it in the QuerySet. 1 2 3 >>> Student = Student . objects . annotate ( full_name = L ( \"full_name\" )) . first () >>> Student . full_name 'John Doe' This bypasses the python code/override, which can be more efficient when fetching multiple rows at once (especially if the property contains complex expressions or joins). See the concrete argument on lookup_property decorator if you always want this behavior.","title":"Annotating"},{"location":"usage/#related-lookups","text":"The L expression also allows you to use the lookup property in related lookups: 1 >>> Class . objects . filter ( L ( students__full_name = \"John Doe\" )) This will find the appropriate model where the lookup property is defined and add the necessary joins to the query automatically.","title":"Related lookups"},{"location":"usage/#subqueries","text":"If the lookup property is used in a subquery in an OuterRef, note that the L expression should wrap the whole subquery, and not just the OuterRef, since the lookup property is located in the outer query model and not the subquery model. 1 2 3 4 5 >>> from django.db.models import OuterRef , Subquery >>> from myapp.models import Class , Person >>> >>> sq = Class . objecs . filter ( teacher_name = OuterRef ( \"full_name\" )) . values ( \"pk\" ) >>> Person . objects . filter ( id__in = L ( models . Subquery ( sq )))","title":"Subqueries"},{"location":"usage/#additional-lookups","text":"Lookup property can be used with additional lookups, such as __in , __lt , __gt , etc. 1 >>> Student . objects . filter ( L ( full_name__in = [ \"John Doe\" , \"Jane Doe\" ]))","title":"Additional lookups"}]}