# How to Use

A simple example:

```python
from lookup_property import lookup_property
from django.db import models
from django.db.models import Value
from django.db.models.functions import Concat

class Person(models.Model):
    first_name = models.CharField(max_length=256)
    last_name = models.CharField(max_length=256)

    @lookup_property
    def full_name(self):
        return Concat("first_name", Value(" "), "last_name")
```

## How does it work?

The method decorated by the `lookup_property` decorator should return
a Django ORM Expression. The expression should not contain any
self-instance references, and should instead use F-objects to refer
to other model fields (or even other lookup-properties).
See note about relations below.

This expression will then be registered to the model's fields via
a custom model Field and Col-expression. The method can be queried
in a queryset like any other model field:

```python
>>> person = Person.objects.filter(full_name="John Doe").first()
```

This also works through related models and sub-queries.

The method expression will also be converted to equivalent python
expression, which allows using the lookup-property like a normal property:

```python
>> person.full_name
'John Doe'
```

You can inspect the generated python source like this:

```python
>>> Person.full_name.func_source
"""
def full_name(self):
    return self.first_name + (' ' + self.last_name)
"""
```

The source code is generated by first converting the Django ORM expression to
a python [AST] using pre-registered converters. The library already provides
converters for most of the common expressions, but it's also possible to
register new converters or replace existing ones (see. [converters](/converters/)).

Then, the AST is evaluated to the python expression using `eval()`.
While use of `eval()` should generally be avoided due to security
concerns, here the risks are minimal, since the evaluation only happens
once during class creation, and from existing code rather than user input.
Still, any extensions like new converters should keep this in mind,
and not, for example, read any input from a database during the conversion process.

Finally, the generated python expression is registered on the lookup-property,
where it will be called when accessing the property via the [descriptor] protocol.

## Related models

While forward relations (relation field is on the model the lookup-property is on)
work normally, reverse relations and many-to-many relations require some hinting
for joins to work properly in some cases (e.g. `QuerySet.count()`):

```python
from lookup_property import lookup_property, State
from django.db import models

class Person(models.Model):
    ...

    @lookup_property(State(joins=True))  # hint that expression contains joins
    def primary_address(self):
        return (
            models.F("addresses__street")
            + models.Value(", ")
            + models.F("addresses__postal_code")
            + models.Value(" ")
            + models.F("addresses__city")
            + models.Value(", ")
            + models.F("addresses__country")
        )


class Address(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="addresses")
    street = models.CharField(max_length=256)
    postal_code = models.CharField(max_length=5)
    city = models.CharField(max_length=256)
    country = models.CharField(max_length=256)
```

This can be specified for forward relations as well without any negative effects.

## Python expression override

Hold on, let's look at the python expression generated for the previous example:

```python
>>> Person.primary_address.func_source
"""
def primary_address(self):
    return (
        self.addresses.street +
        ', ' +
        self.addresses.postal_code +
        ' ' +
        self.addresses.city +
        ', ' +
        self.addresses.country
    )
"""
```

This isn't right, since `self.addresses` is a `RelatedManager` for a one-to-many
relation. In this case, we can declare an explicit override for the generated function:

```python
from lookup_property import lookup_property, State
from django.db import models

class Person(models.Model):
    ...

    @lookup_property(State(joins=True))
    def primary_address(self):
        return ...

    @primary_address.override
    def _(self):
        addr = self.addresses.first()
        return f"{addr.street}, {addr.postal_code} {addr.city}, {addr.country}"
```

In this case, the author would need to make sure that the override has the same
functionality as the lookup-property expression.


[AST]: https://docs.python.org/3/library/ast.html
[descriptor]: https://docs.python.org/3/howto/descriptor.html
